<section>
  <section>
    <h4>Let's take a moment to talk about...</h4>
    <img
      class="fragment margin-bottom-minus-fifteen-percent"
      height="85%"
      src="assets/images/gilderoy-lockhart-recursion.jpg"
    >
    <h1 class="fragment">Recursion</h1>
  </section>
  <section>
    <h4>Revisiting our recursive example...</h4>
    <div class="columns-2">
      <div class="column">
        <div class="fragment">
          <p class="font-size-md text-align-left">Example:</p>
          <pre><code contenteditable class="ruby">
def recursive_countdown(i = 5)
  puts i
  return if i.zero?
  recursive_countdown(i - 1)
end

recursive_countdown
          </code></pre>
        </div>
        <div class="fragment">
          <p class="font-size-md text-align-left">Output:</p>
          <pre><code contenteditable>
5
4
3
2
1
0
          </code></pre>
        </div>
      </div>
      <div class="column">
        <div class="fragment">
          <p class="font-size-md text-align-left">Unwound:</p>
          <pre><code contenteditable class="code-unbound">
recursive_countdown(5)
puts 5
return if 5.zero? # false
recursive_countdown(5 - 1)
puts 4
return if 4.zero? # false
recursive_countdown(4 - 1)
puts 3
return if 3.zero? # false
recursive_countdown(3 - 1)
puts 2
return if 2.zero? # false
recursive_countdown(2 - 1)
puts 1
return if 1.zero? # false
recursive_countdown(1 - 1)
puts 0
return if 0.zero? # true
# Fin
          </code></pre>
        </div>
      </div>
    </div>
  </section>
  <section>
    <h2>Recursion + Tail Call<br><span class="fragment">= Tail Recursion</span></h2>
    <blockquote class="fragment blockquote-unbound">
      If a tail call might lead to the same subroutine being called again later
      in the call chain, the subroutine is said to be
      <strong>tail-recursive</strong>, which is a special case of recursion.
      Tail recursion is particularly useful,
      <span class="fragment highlight-green">especially when combined with tail
      call optimization.</span>
    </blockquote>
  </section>
  <section>
    <h2>Who needs loops?</h2>
    <p>
      Some functional languages take this to an extreme and use recursion, in
      paticular, tail recursion, in place of more typical loop constructs.
    </p>
    <div class="columns-2">
      <div class="column">
        <pre><code contenteditable>
def recursive_countdown(i = 5)
  if i &gt;= 0
    puts i
    recursive_countdown(i - 1)
  end
end
        </code></pre>
      </div>
      <div class="column">
        <pre><code contenteditable>
def iterative_countdown(i = 5)
  while i &gt;= 0
    puts i
    i -= 1
  end
end
        </code></pre>
      </div>
    </div>
    <p>These two approaches are equivalent, but there is a catch.</p>
  </section>
  <section>
    <div class="flames">
      <h4>The catch...</h4>
      <p>
        The link between tail recursion and tail call optimization is so
        important that <span class="fragment highlight-red"
        data-fragment-index="1"> a lack of tail call optimization</span> means that
        recursive solutions aren't really viable for large inputs, which <span
        class="fragment highlight-red" data-fragment-index="1">makes many
        classic functional approaches impossible.</span>
      </p>
    </div>
  </section>
  <section>
    <img
      class="margin-bottom-minus-fifteen-percent"
      height="95%"
      src="assets/images/ron-fire-extinguisher.jpg"
    >
    <h1 class="fragment">Cool it</h1>
  </section>
</section>
